# -*- coding: utf-8 -*-
"""dspy-few-shot-classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vlMSWDlic41ou-9rHLdrU15WXKYA-SQu

## 使用 DSPy 最佳化 classification few-shot prompt 🏆


這個 Notebook 使用 https://dspy-docs.vercel.app/ 進行  prompt 的最佳化

* 輸入你的任務描述以及分類選項
* 就能產出很厲害 few-shot prompt
* 用在有標準答案的單選分類場景

作者和演講投影片: ihower https://ihower.tw/blog/archives/12444

### 流程

1. 使用 o1-preview 合成訓練問題
2. 使用 gpt-4o 進行 DSPy 最佳化
3. 產生適合 gpt-4o-mini 的 few-shot prompt

## 0. 設定 OpenAI API key

請點 google colab 左邊側欄的鑰匙符號，新增密鑰，名稱是 openai_api_key，值就填 API key
"""

from google.colab import userdata
import json
import os

os.environ["OPENAI_API_KEY"] = userdata.get('openai_api_key')

"""## 1. 設定參數"""

synthetic_model = "o1-preview" # 合成訓練問題的模型，若你沒有 o1 權限，請改用 gpt-4o"
generation_model = "gpt-4o" # 合成 prompt 的模型
prediction_model = "gpt-4o-mini" # 用來執行 prompt 的模型

task_description = "情感分析，從一段留言中分析出文字的語氣" # 任務描述，請修改成你的任務
categories = ['矛盾', '感慨', '忐忑', '釋然', '敬畏', '憐憫', '懷舊', '失落', '心酸', '困惑'] # 分類的標籤，請修改

questions_num = len(categories) * 10  # 要合成多少訓練資料，跟花費的 API 成本有關

"""## 2. 合成最佳化需要的 dataset"""

synthetic_prompt = f"""You are tasked with generating question-answer pairs for a classification task.
The questions should be based on a given task description, and the answers should be one of the provided categories. Here's what you need to do:

First, review the task description:
<task_description>
{task_description}
</task_description>

Next, familiarize yourself with the categories for classification:
<categories>
{categories}
</categories>

Your goal is to create {questions_num} question-answer pairs that are relevant to the task description and can be classified into one of the given categories.

Follow these guidelines when creating the QA pairs:

1. Start with simple, straightforward questions and gradually increase the complexity.
2. Ensure that the more difficult questions require multi-step reasoning or in-depth knowledge.
3. Include a variety of question types (e.g., factual, analytical, hypothetical) relevant to the task description.
4. Ensure that all questions are directly related to the provided task description.
5. Make sure each question can be clearly classified into one of the given categories.

Generate the QA pairs in the following JSON array format:

[
  {{ "question": "Your question here", "answer": "Corresponding category" }},
  {{ "question": "Another question", "answer": "Another category" }},
  ...
]


The returned content must be a valid JSON array containing all generated QA pairs.
Do not add any extra text or explanations outside the JSON array. The returned content should be directly parseable as a JSON array.
All content must be in Traditional Chinese as used in Taiwan.
"""

!pip install litellm

from litellm import completion

messages = [
    { "content": synthetic_prompt, "role": "user"}
]

if not synthetic_model.startswith('o1'):
  response = completion(model=synthetic_model, messages=messages, response_format={ "type": "json_object" })
else:
  # o1 目前還不支援 json mode
  response = completion(model=synthetic_model, messages=messages)

response = response.choices[0].message.content
dataset = json.loads(response)

len(dataset)

dataset

"""## 3. 使用 DSPy 最佳化 few-shot prompt"""

!pip install dspy-ai

import dspy
from dspy.teleprompt import MIPROv2
from dspy.evaluate import answer_exact_match

prompt_llm = dspy.OpenAI(
    model=generation_model,
    api_key=os.environ['OPENAI_API_KEY']
)

task_llm = dspy.OpenAI(
    model=prediction_model,
    api_key=os.environ['OPENAI_API_KEY']
)

dspy.settings.configure(lm=task_llm)

"""如果你用 gpt-4o 跑，dataset 格式可能會跟我用 o1-preview 跑出來不一樣，以下要自己更正一下:"""

few_shot_examples = [
    dspy.Example({'question': q["question"], 'answer': q["answer"]}) for q in dataset
]

trainset = [x.with_inputs('question') for x in few_shot_examples]

"""DSPy 的 code: 定義 prompt 的結構"""

class QuestionLabel(dspy.Signature):
    question = dspy.InputField(desc="The input question to be categorized")
    answer = dspy.OutputField(desc="The assigned category or label for the question")

class QuestionClassification(dspy.Module):
    def __init__(self):
        super().__init__()
        self.classifier = dspy.Predict(QuestionLabel)

    def forward(self, question: str):
        return self.classifier(question=question)

"""MIProv2 優化器的文件: https://dspy-docs.vercel.app/docs/deep-dive/optimizers/miprov2

評估採用內建的 answer_exact_match 方法，有標準答案，就檢查是否一模一樣即可
"""

teleprompter = MIPROv2(prompt_model=prompt_llm, task_model=task_llm, metric=answer_exact_match, num_candidates=10, init_temperature=1, verbose=True)

# 開始跑最佳化迭代
compiled_program = teleprompter.compile(QuestionClassification(), trainset=trainset, requires_permission_to_run=False)

"""## 4. 最後結果

DSPy 不只是最佳化工具，本身就是一個執行框架
"""

compiled_program('班長有什麼了不起，我小學也當過班長啊!')

"""可以把最佳化參數存下來，下次載入使用"""

compiled_program.save("compiled_program.json")

"""觀察最後的最佳化 prompt:"""

print( task_llm.inspect_history(1) )

